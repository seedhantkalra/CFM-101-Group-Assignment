



# The below is a messy prototype for a potential stock weighter. It does not follow all the rules and can be improved upon, which is what
# I am working on in the present. -Daniel Chung. If you want, I will create a short document explaining its theory

def cleanup(old_volatility_data):
    weight_sum = 0
    for n in range(0, len(portfolio.columns)):
        weight_sum = weight_sum + old_volatility_data.iloc[2,n]
    num_stocks = 0
    for n in range(0, len(portfolio.columns)):
        if old_volatility_data.iloc[2,n] >= 0:
            num_stocks = num_stocks + 1
    
    for n in range(0, len(portfolio.columns)):
        if old_volatility_data.iloc[2,n] < 0:
            weight_sum = weight_sum - volatility_data.iloc[2,n]
            old_volatility_data.iloc[1,n] = 0
            old_volatility_data.iloc[2,n] = 0
        #elif volatility_data.iloc[1,n] < weight_sum/(2*num_stocks):
         #   exempted
    for n in range(0, len(portfolio.columns)):
        if (old_volatility_data.iloc[2,n] > weight_sum * 0.2):
            weight_sum = weight_sum - (volatility_data.iloc[2,n] - weight_sum * 0.2)
            old_volatility_data.iloc[2,n] = weight_sum * 0.2
            old_volatility_data.iloc[1,n] = weight_sum * 0.2 + 0.001

    return old_volatility_data

def min_search(stock, volatility_1, weight_1, weight_2):
    if weight_1 == 0 or weight_2 == 0:
        portfolio[stock] = portfolio[stock] * 0
        volatility_2 = volatility(portfolio.sum(axis=1).pct_change())
        return [volatility_2, 0, 0]
    else:
        portfolio[stock] = portfolio[stock] * (weight_2/weight_1)
        volatility_2 = volatility(portfolio.sum(axis=1).pct_change())
        change = (volatility_2 - volatility_1)/(weight_2 - weight_1)
        new_weight = weight_2 - change/pow(abs(change+0.0000001), 0.9)
        return [volatility_2, weight_2, new_weight]

portfolio = pd.DataFrame()
portfolio.index = stock_prices.index

columns = stock_prices.columns
investment = 750000
for n in range(0, len(columns)):
    portfolio[columns[n]] = ((investment/len(columns)) / stock_prices.iloc[0, n]) * stock_prices[columns[n]]

volatility_data = pd.DataFrame()
volatility_data.index = ['Vol1', 'Weight1', 'Weight2']
volatility_data
       
vol1 = volatility(portfolio.sum(axis=1).pct_change())

for j in range(0, len(portfolio_stocks)):
    volatility_data[portfolio_stocks.iloc[j,0]] = [vol1, 1/len(portfolio_stocks.index), 1/len(portfolio_stocks.index) + 0.001]

for i in range(0,100):
    for j in range (0, len(portfolio.columns)):
        results = min_search(volatility_data.columns[j],
                                 volatility_data.iloc[0,j],
                                 volatility_data.iloc[1,j],
                                 volatility_data.iloc[2,j])
        if j == len(portfolio.columns)-1:
            volatility_data.iloc[0,0] = results[0]
        else:
            volatility_data.iloc[0,j+1] = results[0]
        
        volatility_data.iloc[1,j] = results[1]
        volatility_data.iloc[2,j] = results[2]
    volatility_data = cleanup(volatility_data)
    print("vol: ", volatility_data.iloc[0,0])    

dropped_stocks = [stocks for stocks in volatility_data.columns if volatility_data[stocks][2] <= 0]

volatility_data.drop(dropped_stocks, axis=1, inplace=True)
volatility_data






















# Below is a prototype for code that filters out the invalid stocks based on assignment specifications and uses multithreading for time efficinecy
# - Seedhant Kalra 

# Initializing a dataframe for 'raw' data extracted from the .csv file
tickers_raw = pd.read_csv(file, header=None)[0].tolist()

# Empty data structures to store ticker data in
tickers = []
tickers_hist = {}

# Dictionary of all the tickers' closing prices on Nov 25, 2023
tickers_closing_dict = {}

# Function which consumes a ticker and determines the validation based on prerequisites
def validate_ticker(ticker):

    # Extracting ticker info from yFinance
    ticker_info = yf.Ticker(ticker).info

    # Trying every stock and excepting those that throw an error
    try:
        # If the stock is valid, we check for each prerequisite:
        # Checking for USD currency and ensuring it's on the US market
        # NEW CODE: ticker_info['quoteType'] == "EQUITY"
        if ticker_info['currency'] == 'USD' and ticker_info['market'] == 'us_market' and ticker_info['quoteType'] == "EQUITY":
            ticker_hist = yf.Ticker(ticker).history(start=start_date, end=end_date, interval='1d').dropna()

            # Checking monthly volume
            ticker_monthly_trading_days = ticker_hist['Volume'].groupby(pd.Grouper(freq='MS')).count()
            ticker_monthly_volume = ticker_hist['Volume'].groupby(pd.Grouper(freq='MS')).sum()

            # Checking if the month has at least 18 trading days
            for month in ticker_monthly_trading_days.index:
                if ticker_monthly_trading_days.loc[month] < 18:
                    ticker_monthly_volume.drop(month, inplace=True)

            # Checking if the average monthly volume is greater than or equal to 150,000 USD
            if ticker_monthly_volume.mean() >= 150000:
                tickers.append(ticker)
                tickers_hist[ticker] = ticker_hist
                #Get 2023-11-25 closing price data for each ticker
                tickers_closing = yf.Ticker(ticker).history(start='2023-11-25', end='2023-11-26').loc['2023-11-25', 'Close']
                tickers_closing_dict[ticker] = tickers_closing
            else:
                print(f'{ticker} Ticker does not meet average monthly volume requirements')
        else:
            print(f'{ticker} Ticker does not reference stock denominated in USD or is an ETF or index stock')
    except:
        print(f'Error: {ticker} Ticker does not reference a valid stock')

# Empty data structure for threading
threads = []

# Checking validity of each ticker in list of tickers given from threading
for ticker in tickers_raw:
    thread = Thread(target=validate_ticker, args=[ticker])
    thread.start()
    threads.append(thread)

# Using threading
for thread in threads:
    thread.join()


